# Лабораторная работа №3

## Вариант 3

---

### Задача 1. Синхронный TCP сервер: эхо с модификацией строки

Реализовать синхронный TCP-сервер и клиент.

Сервер принимает строку, возвращает её в формате:

> *\<длина строки\>: \<строка в верхнем регистре\>*

**Клиент**
- Подключается к серверу
- Отправляет строку
- Получает ответ и выводит в консоль

*Пример*:

> Клиент: Hello world
> Сервер: 11: HELLO WORLD

**Рекомендации**
- Использовать `boost::asio::ip::tcp::socket` и `read`, `write`
- Буферизация через `boost::asio::streambuf`

---

### Задача 2. Асинхронные вычисления: поиск максимума

Клиент отправляет строку с числами, разделёнными пробелами.  
Сервер асинхронно вычисляет максимум и возвращает его.

*Пример*:

> Клиент: 1 88 5 13
> Сервер: Максимум: 88

**Асинхронность**
- После получения строки сервер использует `boost::asio::post` для запуска фоновой задачи
- Результат отправляется клиенту после завершения вычисления

**Технические детали**
- Разбор строки через `std::istringstream`
- Вычисление — обычный цикл или `std::max_element`

---

### Задача 3. Таймер: отложенная отправка сообщения

Если клиент отправляет сообщение `timer <n>`, сервер отвечает сообщением `Ready in <n> sec`, а затем через `n` секунд отправляет `"Done!"`.

*Пример*:

> Клиент: timer 5
> Сервер: Ready in 5 sec
> (через 5 сек)
> Сервер: Done!

**Инструменты**
- `boost::asio::steady_timer`
- Асинхронная логика: сначала отправка подтверждения, потом задержка, потом результат

---

### Задача 4 (общая для всех вариантов): Реализация многопоточного TCP-сервера с синхронизацией с помощью `boost::asio::strand`

Реализовать многопоточный TCP-сервер, который:
- Обслуживает несколько клиентов одновременно
- Выполняет вычисления в фоновом пуле потоков
- Корректно синхронизирует доступ к общим ресурсам (например, журналу логирования или счётчику подключений)
- Демонстрирует работу `boost::asio::strand` как механизма защиты от состояния гонки (race conditions)

**Сервер должен**
- Запускаться с пулом из `N` потоков (задаётся через аргумент командной строки)
- Принимать TCP-подключения от клиентов
- Для каждого клиента запускать обработку сообщений в асинхронном режиме (не блокировать другие подключения)
- На каждое полученное сообщение выполнять медленную вычислительную задачу (например, подсчёт большого количества простых чисел, факториал, сортировка большого вектора и т.д.)
- Сохранять результат вычислений в общий журнал (`std::vector<std::string>` или лог-файл), к которому обращаются потоки

*Пример сценария*
> Клиент подключается → отправляет число `n` → сервер вычисляет `factorial(n)` → записывает результат в журнал → отправляет клиенту ответ.

**Механизмы синхронизации**
- Все обращения к журналу должны быть синхронизированы с использованием `boost::asio::strand`, а не `std::mutex`
- Любая попытка модифицировать общий ресурс вне `strand` запрещена

**Асинхронность**
- Сообщения от клиентов обрабатываются с помощью `async_read` / `async_write`
- Долгие вычисления выполняются через `boost::asio::post(io_context, handler)` или через `boost::asio::thread_pool`

**Дополнительные требования**
- Реализовать таймаут на подключение (например, через `steady_timer`)
- Добавить обработку исключений и логгирование ошибок
- Обеспечить корректное завершение всех потоков при остановке сервера

**Технические требования**
- Используйте C++17 или выше
- Подключение библиотеки Boost (Asio)
- Структура проекта: `main.cpp`, `server.hpp/cpp`, `client.hpp/cpp`
- Преобразование строк в числа
- Работа с `boost::asio::streambuf`, `socket`
- Асинхронная работа через `post()`, `async_read`, `async_write`

